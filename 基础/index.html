<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		1.常见http接口的返回值
		200 - 确定。客户端请求已成功
		404 - 未找到对应的请求
		401-未授权
		500 - 服务器错误

		2.页面的渲染。html,css,js还有js的defer和async属性
		defer是表明脚本在执行时不会影响页面的构造。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。
		浏览器渲染页面，读取到包含defer属性的外部标签时不会停止DOM渲染，而是异步下载，加载完整个页面再运行js。
		有多个defer的标签时，会按照顺序下载执行。
		async浏览器立即异步下载文件，不同于defer得是，
		下载完成会立即执行，此时会阻塞dom渲染，所以async的script最好不要操作dom。因为是下载完立即执行，不能保证多个加载时的先后顺序。

		3.JS观察者模式和发布订阅模式的区别
		观察者模式: 观察者观察被观察者，当被观察者发生被观察的行为时，触发观察者里面的事件。
		发布订阅模式： 订阅者订阅想要观察的事件，当发布者发布事件时，会去查找对应事件的订阅事件并触发。
		区别： 观察者模式和发布订阅模式都是为了解耦，减少代码的冗余，不同的是，观察者模式中观察者必须知道被观察者，
		而发布订阅模式解耦更彻底，订阅者与发布者不需要相互知道，只需要向事件大厅订阅和发布即可。
		发布订阅模式相比观察者模式多了个事件通道，订阅者和发布者不是直接关联的。

		4.http1和http2区别
		(1)什么是HTTP 2.0
		HTTP/2（超文本传输协议第2版，最初命名为HTTP 2.0），是HTTP协议的的第二个主要版本，使用于万维网。
		HTTP/2是HTTP协议自1999年HTTP 1.1发布后的首个更新，主要基于SPDY协议
		是Google开发的基于TCP的应用层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验）。
		(2)与HTTP 1.1相比，主要区别包括
		HTTP/2采用二进制格式而非文本格式
		HTTP/2是完全多路复用的，而非有序并阻塞的——只需一个连接即可实现并行
		使用报头压缩，HTTP/2降低了开销
		HTTP/2让服务器可以将响应主动“推送”到客户端缓存中
		(3)HTTP/2为什么是二进制？
		比起像HTTP/1.x这样的文本协议，二进制协议解析起来更高效、“线上”更紧凑，更重要的是错误更少。

		5.cookie和localstorage区别
		1、cookie在浏览器与服务器之间来回传递，在客户端请求服务器端和服务器响应时，
		cookie始终被携带在http请求中，即使不需要(造成流量浪费)。这也是限制cookie大小的原因。
		客户端可以通过document.cookie操作cookie，并不安全。
		cookie可以设置过期时间、路径、域和httpOnly等字段。
		如果设置了过期时间，cookie会保存在硬盘里，知道到了设定的过期时间才会失效。
		若未设置过期时间，在浏览器窗口关闭时，cookie就失效了。
		路径和域两个字段限制了cookie的作用范围。httpOnly设置为true，则js不能通过document.cookie操作cookie。
		sessionStorage和localStorage不会把数据发给服务器，仅在本地保存。
		2、数据有效期不同
		cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭
		sessionStorage：仅在当前浏览器窗口关闭前有效
		localStorage 始终有效，长期保存。
		3、cookie数据还有路径的概念，可以限制cookie只属于某个路径下
		存储大小也不同，cookie数据不能超过4k，看域名，有些最多每个域名 cookie 限制为 50 个，sessionStorage和localStorage
		虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。
		4、作用域不用
		sessionStorage不在不同的浏览器窗口中共享
		localStorage在所有同源窗口中都是共享的，存储的信息在同一域中是共享的。
		cookie也是在所有同源窗口中都是共享的

		5.浏览器缓存
		缓存从微观上可以分为以下几类：
		浏览器缓存
		代理缓存
		CDN缓存
		数据库缓存
		应用缓存
		http缓存
		强缓存 不会向服务器发送请求,直接从缓存中读取资源
		协商缓存 当协商缓存生效时,返回304和Not Modified 它指的是强制缓存失效后,浏览器携带缓存标示向服务器发起请求,由服务器决定是否需要使用缓存。
		再次发送请求时，浏览器会首先获取该资源缓存的header信息，然后根据Cache-Control和expires来判断是否过期。若没过期则直接从缓存中获取资源信息，
		包括缓存的header的信息，所以此次请求不会与服务器进行通信。
		如果缓存过期，浏览器会向服务器发送请求，该请求会携带第一次请求返回的有关缓存的header字段信息（IF-Modified-Since、IF-None-Match）,
		由服务器根据请求中的相关header信息来对比结果是否命中协商缓存，
		若命中，它会告知浏览器可以直接从缓存获取,状态为304；否则返回最新的资源内容状态为200

		6.跨域
		(1)同源策略
		-是浏览器安全策略
		-协议名，域名，端口号必须完全一致
		(2)违背了同源策略就会产生跨域
		(3)解决跨域
		jsonp
		jsonp原理及简单实现
		1、首先是利用script标签的src属性来实现跨域。
		2、通过将前端方法作为参数传递到服务器端，然后由服务器端注入参数之后再返回，实现服务器端向客户端通信。
		3、由于使用script标签的src属性，因此只支持get方法
		它没有关于JSONP调用的错误处理，一旦回调函数调用失败，浏览器会以静默失败的方式处理。
		其次，它只支持GET请求，这是由于该技术本身的特性所决定的。因此，对于一些需要对安全性有要求的跨域请求，JSONP的使用需要谨慎一点了。
		<script>
			function showData(result) {
				var data = JSON.stringify(result); //json对象转成字符串
				$("#text").val(data);
			}
			$(document).ready(function() {
				$("#btn").click(function() {
					//向头部输入一个脚本，该脚本发起一个跨域请求
					$("head").append("<script src='http://localhost:9090/student?callback=showData'><\/script>");
				});

			});
		</script>
		cors
		服务器代理

		7.请求头的参数
		User-Agent：浏览器名称。
		Referer：表明当前这个请求是从哪个url过来的。这个一般也可以用来做反爬虫技术。如果不是从指定页面过来的，那么就不做相关的响应。
		cookie：http协议是无状态的。也就是同一个人发送了两次请求，服务器没有能力知道这两个请求是否来自同一个人。
		因此这时候就用cookie来做标识。一般如果想要做登录后才能访问的网站，那么就需要发送cookie信息了。
		Accept 告诉WEB服务器自己接受什么介质类型，*/* 表示任何类型，type/* 表示该类型下的所有子类型，type/sub-type
		Accept-Charset 浏览器告诉服务器自己能接收的字符集
		Host 客户端指定自己想访问的WEB服务器的域名/IP 地址和端口号

		8.前端工程化
		前端工程化就是通过各种工具和技术，提升前端开发效率的过程。这句话有两个含义：
		1：前端工程化的内容：各种工具和技术
		2：前端工程化的作用：通过使用工具，提升开发效率
		模块化，组件化，规范化和自动化

		9.从一个url地址到最终页面渲染完成，发生了什么
		1.DNS解析：将域名地址解析为ip地址
		-浏览器DNS缓存
		-系统DNS缓存
		-路由器DNS缓存
		-网络运营商DNS缓存
		-递归搜索 blog.baidu.com
		-.com域名下查找DNS解析
		-.baidu域名下查找DNS解析
		-blog域名下查找DNS解析
		-出错了
		2.TCP连接:TCP三次握手
		-第一次握手，由浏览器发起，告诉服务器我要发送请求了
		-第二次握手，由服务器发起，告诉我浏览器我准备接受了，你赶紧发送吧
		-第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧
		3.发送请求
		-请求报文:HTTP协议的通信内容
		4.接收响应
		-响应报文
		5.渲染页面
		-遇见HTML标记，浏览器调用HTML解析器解析成Token并构建成dom树
		-遇见style/link标记，浏览器调用css解析器，处理css标记并构建cssom树
		-遇见script标记，调用javascript解析器，处理script代码(绑定事件，修改dom树/cssom树)
		-将dom树和cssom树合并成一个渲染树
		-根据渲染树来计算布局，计算每个节点的几何信息（布局）
		-将各个节点颜色绘制到屏幕上（渲染）
		这五个步骤不一定按照顺序执行，如果dom树或cssom树被修改了，可能会执行多次布局和渲染
		往往实际页面中，这些步骤都会执行多次的
		6.断开连接：TCP四次挥手
		-第一次挥手：由浏览器发起，发送给服务器，我东西发送完了(请求报文)，你准备关闭吧
		-第二次挥手，由服务器发起，告诉浏览器，我东西接受完了（请求报文），我准备关闭了，你也准备吧
		-第三次挥手：由服务器发起，告诉浏览器，我东西发送完了(响应报文)，你准备关闭吧
		-第四次挥手，由浏览器发起，告诉服务器，我东西接收完了(响应报文)，你也准备吧


	</body>
